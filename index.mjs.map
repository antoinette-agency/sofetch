{
  "version": 3,
  "sources": ["src/soFetchConfig.ts", "src/soFetchPromise.ts", "src/sleep.ts", "src/getPayloadType.ts", "src/soFetch.ts", "src/index.ts"],
  "sourcesContent": ["import {ErrorHandlerDict} from \"./errorHandlerDict.ts\";\r\nimport {SoFetchRequest} from \"./soFetch.ts\";\r\n\r\nexport class SoFetchConfig {\r\n    errorHandlers:ErrorHandlerDict = {}\r\n    beforeSendHandlers:((request:SoFetchRequest) => SoFetchRequest | void)[] = []\r\n    onRequestCompleteHandlers:((response:Response, requestData:{duration:number, method:string}) => void)[] = []\r\n    baseUrl: string = \"\"\r\n\r\n    addHTTPHandler(status: number, handler: (res: Response) => void) {\r\n        if (!this.errorHandlers[status]) {\r\n            this.errorHandlers[status] = []\r\n        }\r\n        this.errorHandlers[status].push(handler)\r\n    }\r\n\r\n    handleHttpError(response: Response) {\r\n        const status = response.status\r\n        const handled = this.errorHandlers[status] && this.errorHandlers[status].length\r\n        if (handled) {\r\n            this.errorHandlers[status].forEach(h => h(response))\r\n        }\r\n        return handled\r\n    }\r\n\r\n    setBasicAuthentication({username, password}: {password: string; username: string}) {\r\n        const token = btoa(`${username}:${password}`);\r\n        const headerValue = `Basic ${token}`\r\n        this.beforeSend((request: SoFetchRequest) => {\r\n            request.headers[\"Authorization\"] = headerValue\r\n        })\r\n    }\r\n\r\n    setBearerToken(token: string) {\r\n        this.beforeSend((request: SoFetchRequest) => {\r\n            request.headers[\"Authorization\"] = `Bearer ${token}`\r\n        })\r\n    }\r\n\r\n    setHeaderApiKey({headerName, value}: {headerName: string; value: string}) {\r\n        this.beforeSend((request: SoFetchRequest) => {\r\n            request.headers[headerName] = value\r\n        })\r\n    }\r\n\r\n    setQueryStringApiKey({paramName, value}: { paramName: string; value: string }) {\r\n        this.beforeSend((request: SoFetchRequest) => {\r\n            const url = new URL(request.url)\r\n            url.searchParams.append(paramName, value)\r\n            request.url = url.toString()\r\n        })\r\n    }\r\n\r\n    beforeSend(handler: (request: SoFetchRequest) => SoFetchRequest | void) {\r\n        this.beforeSendHandlers.push(handler)\r\n    }\r\n\r\n    transformRequest(request:SoFetchRequest):SoFetchRequest {\r\n        this.beforeSendHandlers.forEach(h => {\r\n            request = h(request) || request\r\n        })\r\n        return request\r\n    }\r\n\r\n    onRequestComplete(handler: (r: Response, metaData:{duration:number, method:string}) => void) {\r\n        this.onRequestCompleteHandlers.push(handler)\r\n    }\r\n}", "import {ErrorHandlerDict} from \"./errorHandlerDict.ts\";\r\nimport {SoFetchRequest} from \"./soFetch.ts\";\r\n\r\nexport class SoFetchPromise<T> extends EventTarget {\r\n    private readonly inner: Promise<T>;\r\n    private errorHandlers:ErrorHandlerDict = {}\r\n    private beforeSendHandlers:((request:SoFetchRequest) => SoFetchRequest | void)[] = []\r\n    private beforeFetchSendHandlers:((init:RequestInit) => RequestInit | void)[] = []\r\n    timeout: number = 30000\r\n    then: Promise<T>[\"then\"];\r\n    catch: Promise<T>[\"catch\"];\r\n    finally: Promise<T>[\"finally\"];\r\n    \r\n    constructor(executor: (\r\n        resolve: (value: T | PromiseLike<T>) => void,\r\n        reject: (reason?: any) => void\r\n    ) => void) {\r\n        super();\r\n        this.inner = new Promise(executor);\r\n        // Bind promise methods once inner exists\r\n        this.then = this.inner.then.bind(this.inner);\r\n        this.catch = this.inner.catch.bind(this.inner);\r\n        this.finally = this.inner.finally.bind(this.inner);\r\n    }\r\n\r\n    onRequestComplete(handler: (response: Response) => void): SoFetchPromise<T> {\r\n        this.addEventListener(\"onRequestSuccess\", e => {\r\n            const event = e as CustomEvent<Response>;\r\n            handler(event.detail)\r\n        })\r\n        return this\r\n    }\r\n    \r\n    beforeSend(handler: (request: SoFetchRequest) => SoFetchRequest | void): SoFetchPromise<T> {\r\n        this.beforeSendHandlers.push(handler)\r\n        return this\r\n    }\r\n\r\n    beforeFetchSend(handler: (request: RequestInit) => RequestInit | void): SoFetchPromise<T> {\r\n        this.beforeFetchSendHandlers.push(handler)\r\n        return this\r\n    }\r\n\r\n\r\n    catchHTTP(status: number, handler: (response: Response) => void): SoFetchPromise<T> {\r\n        if (!this.errorHandlers[status]) {\r\n            this.errorHandlers[status] = []\r\n        }\r\n        this.errorHandlers[status].push(handler)\r\n        return this\r\n    }\r\n\r\n    handleHttpError(response:Response) {\r\n        const status = response.status\r\n        const handled = this.errorHandlers[status] && this.errorHandlers[status].length\r\n        if (handled) {\r\n            this.errorHandlers[status].forEach(h => h(response))\r\n        }\r\n        return handled\r\n    }\r\n\r\n    transformRequest(request:SoFetchRequest):SoFetchRequest {\r\n        this.beforeSendHandlers.forEach(h => {\r\n            request = h(request) || request\r\n        })\r\n        return request\r\n    }\r\n\r\n    transformInit(init:RequestInit):RequestInit {\r\n        this.beforeFetchSendHandlers.forEach(h => {\r\n            init = h(init) || init\r\n        })\r\n        return init\r\n    }\r\n\r\n    async setTimeout(ms: number) {\r\n        this.timeout = ms\r\n        return this\r\n    }\r\n}", "export function sleep(ms: number) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}", "import {UploadPayload} from \"./uploadPayload.ts\";\r\nimport {FileWithFieldName} from \"./fileWithFieldName.ts\";\r\n\r\nexport const normalisePayload = (payload:UploadPayload):{files?:FileWithFieldName[], jsonPayload?:object} => {\r\n    const {isDefined, isArray, isFiles} = getPayloadType(payload)\r\n    if (!isDefined) {\r\n        return {}\r\n    }\r\n    if (!isFiles) {\r\n        return {jsonPayload:payload}\r\n    }\r\n    const fileArray = (isArray ? payload : [payload]) as (File[] | FileWithFieldName[])\r\n    const files = (isFileWithFieldName(fileArray[0]) ? fileArray : fileArray.map(((x,i) => ({file:x, fieldName:`file${i}`})))) as FileWithFieldName[]\r\n    return {files}\r\n}\r\n\r\nexport const isFileWithFieldName = (v:object) => {\r\n    return 'file' in v && v.file instanceof File\r\n}\r\n\r\nexport const getPayloadType = (payload: UploadPayload): { isDefined: boolean, isArray: boolean, isFiles: boolean } => {\r\n    if (!payload) {\r\n        return {isDefined: false, isArray: false, isFiles: false}\r\n    }\r\n    if (Array.isArray(payload)) {\r\n        if (!payload.length) {\r\n            //For the purposes of the HTTP request a payload which is an empty array is undefined\r\n            //We won't be sending a body with the request.\r\n            return {isDefined: false, isArray: true, isFiles: false}\r\n        }\r\n        if (payload[0] instanceof File) {\r\n            return {isDefined: true, isArray: true, isFiles: true}\r\n        }\r\n        if (isFileWithFieldName(payload[0])) {\r\n            return {isDefined: true, isArray: true, isFiles: true}\r\n        }\r\n        return {isDefined: true, isArray: true, isFiles: false}\r\n    }\r\n    if (payload instanceof File) {\r\n        return {isDefined: true, isArray: false, isFiles: true}\r\n    }\r\n    if (isFileWithFieldName(payload)) {\r\n        return {isDefined: true, isArray: false, isFiles: true}\r\n    }\r\n    return {isDefined: true, isArray: false, isFiles: false}\r\n}", "import {SoFetchConfig} from \"./soFetchConfig.ts\";\r\nimport {SoFetchPromise} from \"./soFetchPromise.ts\";\r\nimport {sleep} from \"./sleep.ts\";\r\nimport {UploadPayload} from \"./uploadPayload.ts\";\r\nimport {normalisePayload} from \"./getPayloadType.ts\";\r\nimport {FileWithFieldName} from \"./fileWithFieldName.ts\";\r\nimport {SoFetchLike} from \"./soFetchLike.ts\";\r\n\r\nconst makeRequestWrapper = <TResponse>(config: SoFetchConfig, method:string, url:string, body?:UploadPayload) => {\r\n    const promise = new SoFetchPromise<TResponse>((resolve, reject) => {\r\n        (async () => {\r\n            const headers = {}\r\n            let request = {url, method, body, headers}\r\n            request.url = !config.baseUrl || request.url.startsWith(\"http\") ? request.url : `${config.baseUrl}${request.url}`\r\n            await sleep(0) //Allows the promise to be initialised\r\n            request = promise.transformRequest(request)\r\n            request = config.transformRequest(request)\r\n            const {files, jsonPayload} = normalisePayload(request.body)\r\n            let init = files ? makeFilesRequest(request, files) : makeJsonRequest(request)\r\n            init = promise.transformInit(init)\r\n            \r\n            const startTime = new Date().getTime()\r\n            const response = await Promise.race([\r\n                fetch(request.url, init),\r\n                new Promise<Response>((_, reject) =>\r\n                    setTimeout(() => reject(new Error(\"SoFetch timed out\")), promise.timeout)\r\n                )\r\n            ]);\r\n            const duration = new Date().getTime() - startTime\r\n            if (soFetch.verbose) {\r\n                console.info(`SoFetch: ${init.method} ${response.status} ${request.url}`)\r\n            }\r\n            promise.dispatchEvent(new CustomEvent(\"onRequestSuccess\", {detail:response}))\r\n            config.onRequestCompleteHandlers.forEach(h => {\r\n                h(response, {duration, method:request.method})\r\n            })\r\n            if (!response.ok) {\r\n                const requestHandled = promise.handleHttpError(response)\r\n                const configHandled = config.handleHttpError(response)\r\n                if (!requestHandled && !configHandled) {\r\n                    throw new Error(`Received response ${response.status} from URL ${response.url}`, {cause: response})\r\n                }\r\n            }\r\n            const returnObject = await handleResponse(response)\r\n            resolve(returnObject)\r\n        })().catch(e => {\r\n            reject(e)\r\n        })\r\n    })\r\n    return promise\r\n}\r\n\r\nexport interface SoFetchRequest {\r\n    url:string,\r\n    method:string,\r\n    body:object | undefined\r\n    headers:Record<string,string>\r\n}\r\n\r\nconst makeJsonRequest = (request:SoFetchRequest):RequestInit => {\r\n    const {url, method, body} = request\r\n    request.headers['content-type'] = 'application/json'\r\n    const init = {\r\n        body: body ? JSON.stringify(body) : undefined,\r\n        headers: request.headers,\r\n        method,\r\n        credentials: \"include\" as RequestCredentials\r\n    }\r\n    return init\r\n}\r\n\r\nconst makeFilesRequest = (request:SoFetchRequest, files:FileWithFieldName[]):RequestInit => {\r\n    const {method, headers} = request\r\n    const formData = new FormData()\r\n    files.forEach(f => {\r\n        formData.append(f.fieldName, f.file, f.file.name)\r\n    })\r\n    const init = {\r\n        body: formData,\r\n        headers,\r\n        method,\r\n        credentials: \"include\" as RequestCredentials\r\n    }\r\n    return init\r\n}\r\n\r\nconst handleResponse = async (response:Response) => {\r\n\r\n    if (response.status === 203) {\r\n        return undefined\r\n    }\r\n\r\n    const responseBody = await response.text();\r\n    if (!responseBody) {\r\n        return undefined\r\n    }\r\n    let responseObject: any = responseBody\r\n    try {\r\n        responseObject = JSON.parse(responseBody);\r\n    } catch {\r\n    }\r\n\r\n    return responseObject\r\n}\r\n\r\nconst soFetch = (<TResponse>(url: string, body?: object | File | File[]): SoFetchPromise<TResponse> => {\r\n    return makeRequestWrapper<TResponse>(soFetch.config || new SoFetchConfig(), body ? \"POST\" : \"GET\", url,  body)\r\n}) as SoFetchLike;\r\n\r\nsoFetch.verbose = false;\r\nsoFetch.config = new SoFetchConfig()\r\n\r\nsoFetch.get = (url: string, body?: object) => {\r\n    return makeRequestWrapper( soFetch.config,\"GET\", url, body)\r\n}\r\n\r\nsoFetch.post = (url: string, body?: object) => {\r\n    return makeRequestWrapper(soFetch.config,\"POST\", url, body)\r\n}\r\n\r\nsoFetch.put = (url: string, body?: object) => {\r\n    return makeRequestWrapper(soFetch.config,\"PUT\", url, body)\r\n}\r\n\r\nsoFetch.patch = (url: string, body?: object) => {\r\n    return makeRequestWrapper(soFetch.config,\"PATCH\", url, body)\r\n}\r\n\r\nsoFetch.delete = (url: string, body?: object) => {\r\n    return makeRequestWrapper(soFetch.config,\"DELETE\", url, body)\r\n}\r\n\r\nsoFetch.instance = () => {\r\n    \r\n    const config = new SoFetchConfig()\r\n    config.baseUrl = soFetch.config.baseUrl\r\n    config.beforeSendHandlers = [...soFetch.config.beforeSendHandlers]\r\n    config.onRequestCompleteHandlers = [...soFetch.config.onRequestCompleteHandlers]\r\n    \r\n    const soFetchInstance = (<TResponse>(url: string, body?: object | File | File[]): SoFetchPromise<TResponse> => {\r\n        return makeRequestWrapper<TResponse>(config,body ? \"POST\" : \"GET\", url,  body)\r\n    }) as SoFetchLike;\r\n    soFetchInstance.get = (url: string, body?: object | File | File[]) => {\r\n        return makeRequestWrapper(config, \"GET\", url, body)\r\n    }\r\n    soFetchInstance.post = (url: string, body?: object | File | File[]) => {\r\n        return makeRequestWrapper(config,\"POST\", url, body)\r\n    }\r\n    soFetchInstance.put = (url: string, body?: object | File | File[]) => {\r\n        return makeRequestWrapper(config,\"PUT\", url, body)\r\n    }\r\n    soFetchInstance.patch = (url: string, body?: object | File | File[]) => {\r\n        return makeRequestWrapper(config,\"PATCH\", url, body)\r\n    }\r\n    soFetchInstance.delete = (url: string, body?: object | File | File[]) => {\r\n        return makeRequestWrapper(config,\"DELETE\", url, body)\r\n    }\r\n    soFetchInstance.verbose = soFetch.verbose\r\n    soFetchInstance.config = config\r\n    return soFetchInstance\r\n}\r\n\r\nexport default soFetch;\r\n", "import soFetch, { SoFetchRequest } from \"./soFetch.ts\";\r\nimport {SoFetchPromise} from \"./soFetchPromise.ts\";\r\nimport {SoFetchConfig} from \"./soFetchConfig.ts\";\r\nimport {SoFetchLike} from \"./soFetchLike.ts\";\r\n\r\nexport default soFetch\r\n\r\nexport {SoFetchPromise, SoFetchConfig}\r\n\r\nexport type {SoFetchLike, SoFetchRequest}"],
  "mappings": "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",
  "names": ["SoFetchConfig", "status", "handler", "response", "handled", "h", "username", "password", "headerValue", "request", "token", "headerName", "value", "paramName", "url", "SoFetchPromise", "executor", "handler", "e", "status", "response", "handled", "h", "request", "init", "ms", "sleep", "ms", "resolve", "normalisePayload", "payload", "isDefined", "isArray", "isFiles", "getPayloadType", "fileArray", "isFileWithFieldName", "x", "i", "v", "makeRequestWrapper", "config", "method", "url", "body", "promise", "SoFetchPromise", "resolve", "reject", "request", "sleep", "files", "jsonPayload", "normalisePayload", "init", "makeFilesRequest", "makeJsonRequest", "startTime", "response", "_", "duration", "soFetch", "h", "requestHandled", "configHandled", "returnObject", "handleResponse", "e", "headers", "formData", "f", "responseBody", "responseObject", "SoFetchConfig", "soFetchInstance", "soFetch_default", "index_default", "soFetch_default"]
}
