{
  "version": 3,
  "sources": ["src/soFetchConfig.ts", "src/soFetchPromise.ts", "src/sleep.ts", "src/getPayloadType.ts", "src/soFetch.ts", "src/index.ts"],
  "sourcesContent": ["import {ErrorHandlerDict} from \"./errorHandlerDict.ts\";\r\nimport {SoFetchRequest} from \"./soFetch.ts\";\r\n\r\nexport class SoFetchConfig {\r\n    private errorHandlers:ErrorHandlerDict = {}\r\n    private beforeSendHandlers:((request:SoFetchRequest) => SoFetchRequest | void)[] = []\r\n    constructor() {\r\n    }\r\n    baseUrl: string = \"\"\r\n\r\n    addHTTPHandler(status: number, handler: (res: Response) => void) {\r\n        if (!this.errorHandlers[status]) {\r\n            this.errorHandlers[status] = []\r\n        }\r\n        this.errorHandlers[status].push(handler)\r\n    }\r\n\r\n    handleHttpError(response: Response) {\r\n        const status = response.status\r\n        const handled = this.errorHandlers[status] && this.errorHandlers[status].length\r\n        if (handled) {\r\n            this.errorHandlers[status].forEach(h => h(response))\r\n        }\r\n        return handled\r\n    }\r\n\r\n    setBasicAuthentication({username, password}: {password: string; username: string}) {\r\n        const token = btoa(`${username}:${password}`);\r\n        const headerValue = `Basic ${token}`\r\n        this.beforeSend((request: SoFetchRequest) => {\r\n            request.headers[\"Authorization\"] = headerValue\r\n        })\r\n    }\r\n\r\n    setBearerToken(token: string) {\r\n        this.beforeSend((request: SoFetchRequest) => {\r\n            request.headers[\"Authorization\"] = `Bearer ${token}`\r\n        })\r\n    }\r\n\r\n    setHeaderApiKey({headerName, value}: {headerName: string; value: string}) {\r\n        this.beforeSend((request: SoFetchRequest) => {\r\n            request.headers[headerName] = value\r\n        })\r\n    }\r\n\r\n    setQueryStringApiKey({paramName, value}: { paramName: string; value: string }) {\r\n        this.beforeSend((request: SoFetchRequest) => {\r\n            const url = new URL(request.url)\r\n            url.searchParams.append(paramName, value)\r\n            request.url = url.toString()\r\n        })\r\n    }\r\n\r\n    beforeSend(handler: (request: SoFetchRequest) => SoFetchRequest | void) {\r\n        this.beforeSendHandlers.push(handler)\r\n    }\r\n\r\n    transformRequest(request:SoFetchRequest):SoFetchRequest {\r\n        this.beforeSendHandlers.forEach(h => {\r\n            request = h(request) || request\r\n        })\r\n        return request\r\n    }\r\n}", "import {ErrorHandlerDict} from \"./errorHandlerDict.ts\";\r\nimport {SoFetchRequest} from \"./soFetch.ts\";\r\n\r\nexport class SoFetchPromise<T> extends EventTarget {\r\n    private readonly inner: Promise<T>;\r\n    private errorHandlers:ErrorHandlerDict = {}\r\n    private beforeSendHandlers:((request:SoFetchRequest) => SoFetchRequest | void)[] = []\r\n    private beforeFetchSendHandlers:((init:RequestInit) => RequestInit | void)[] = []\r\n    timeout: number = 30000\r\n    then: Promise<T>[\"then\"];\r\n    catch: Promise<T>[\"catch\"];\r\n    finally: Promise<T>[\"finally\"];\r\n    \r\n    constructor(executor: (\r\n        resolve: (value: T | PromiseLike<T>) => void,\r\n        reject: (reason?: any) => void\r\n    ) => void) {\r\n        super();\r\n        this.inner = new Promise(executor);\r\n        // Bind promise methods once inner exists\r\n        this.then = this.inner.then.bind(this.inner);\r\n        this.catch = this.inner.catch.bind(this.inner);\r\n        this.finally = this.inner.finally.bind(this.inner);\r\n    }\r\n\r\n    onRequestComplete(handler: (response: Response) => void): SoFetchPromise<T> {\r\n        this.addEventListener(\"onRequestSuccess\", e => {\r\n            const event = e as CustomEvent<Response>;\r\n            handler(event.detail)\r\n        })\r\n        return this\r\n    }\r\n    \r\n    beforeSend(handler: (request: SoFetchRequest) => SoFetchRequest | void): SoFetchPromise<T> {\r\n        this.beforeSendHandlers.push(handler)\r\n        return this\r\n    }\r\n\r\n    beforeFetchSend(handler: (request: RequestInit) => RequestInit | void): SoFetchPromise<T> {\r\n        this.beforeFetchSendHandlers.push(handler)\r\n        return this\r\n    }\r\n\r\n\r\n    catchHTTP(status: number, handler: (response: Response) => void): SoFetchPromise<T> {\r\n        if (!this.errorHandlers[status]) {\r\n            this.errorHandlers[status] = []\r\n        }\r\n        this.errorHandlers[status].push(handler)\r\n        return this\r\n    }\r\n\r\n    handleHttpError(response:Response) {\r\n        const status = response.status\r\n        const handled = this.errorHandlers[status] && this.errorHandlers[status].length\r\n        if (handled) {\r\n            this.errorHandlers[status].forEach(h => h(response))\r\n        }\r\n        return handled\r\n    }\r\n\r\n    transformRequest(request:SoFetchRequest):SoFetchRequest {\r\n        this.beforeSendHandlers.forEach(h => {\r\n            request = h(request) || request\r\n        })\r\n        return request\r\n    }\r\n\r\n    transformInit(init:RequestInit):RequestInit {\r\n        this.beforeFetchSendHandlers.forEach(h => {\r\n            init = h(init) || init\r\n        })\r\n        return init\r\n    }\r\n\r\n    async setTimeout(ms: number) {\r\n        this.timeout = ms\r\n        return this\r\n    }\r\n}", "export function sleep(ms: number) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}", "import {UploadPayload} from \"./uploadPayload.ts\";\r\nimport {FileWithFieldName} from \"./fileWithFieldName.ts\";\r\n\r\nexport const normalisePayload = (payload:UploadPayload):{files?:FileWithFieldName[], jsonPayload?:object} => {\r\n    const {isDefined, isArray, isFiles} = getPayloadType(payload)\r\n    if (!isDefined) {\r\n        return {}\r\n    }\r\n    if (!isFiles) {\r\n        return {jsonPayload:payload}\r\n    }\r\n    const fileArray = (isArray ? payload : [payload]) as (File[] | FileWithFieldName[])\r\n    const files = (isFileWithFieldName(fileArray[0]) ? fileArray : fileArray.map(((x,i) => ({file:x, fieldName:`file${i}`})))) as FileWithFieldName[]\r\n    return {files}\r\n}\r\n\r\nexport const isFileWithFieldName = (v:object) => {\r\n    return 'file' in v && v.file instanceof File\r\n}\r\n\r\nexport const getPayloadType = (payload: UploadPayload): { isDefined: boolean, isArray: boolean, isFiles: boolean } => {\r\n    if (!payload) {\r\n        return {isDefined: false, isArray: false, isFiles: false}\r\n    }\r\n    if (Array.isArray(payload)) {\r\n        if (!payload.length) {\r\n            //For the purposes of the HTTP request a payload which is an empty array is undefined\r\n            //We won't be sending a body with the request.\r\n            return {isDefined: false, isArray: true, isFiles: false}\r\n        }\r\n        if (payload[0] instanceof File) {\r\n            return {isDefined: true, isArray: true, isFiles: true}\r\n        }\r\n        if (isFileWithFieldName(payload[0])) {\r\n            return {isDefined: true, isArray: true, isFiles: true}\r\n        }\r\n        return {isDefined: true, isArray: true, isFiles: false}\r\n    }\r\n    if (payload instanceof File) {\r\n        return {isDefined: true, isArray: false, isFiles: true}\r\n    }\r\n    if (isFileWithFieldName(payload)) {\r\n        return {isDefined: true, isArray: false, isFiles: true}\r\n    }\r\n    return {isDefined: true, isArray: false, isFiles: false}\r\n}", "import {SoFetchConfig} from \"./soFetchConfig.ts\";\r\nimport {SoFetchPromise} from \"./soFetchPromise.ts\";\r\nimport {sleep} from \"./sleep.ts\";\r\nimport {UploadPayload} from \"./uploadPayload.ts\";\r\nimport {FilesPayload} from \"./filesPayload.ts\";\r\nimport {getPayloadType, normalisePayload} from \"./getPayloadType.ts\";\r\nimport {FileWithFieldName} from \"./fileWithFieldName.ts\";\r\n\r\nexport interface SoFetchLike<TResponse = unknown>  {\r\n    verbose: boolean;\r\n    config: SoFetchConfig;\r\n    get<T>(url: string, body?: object):SoFetchPromise<T>;\r\n    post<T>(url: string, body?: object):SoFetchPromise<T>;\r\n    put<T>(url: string, body?: object):SoFetchPromise<T>;\r\n    patch<T>(url: string, body?: object):SoFetchPromise<T>;\r\n    delete<T>(url: string, body?: object):SoFetchPromise<T>;\r\n    <T extends TResponse = TResponse>(url: string, body?: object | File | File[], files?:File | File[]): SoFetchPromise<T>;\r\n};\r\n\r\nconst makeRequestWrapper = <TResponse>(method:string, url:string, body?:UploadPayload, files?:FilesPayload) => {\r\n    const promise = new SoFetchPromise<TResponse>((resolve, reject) => {\r\n        (async () => {\r\n            const headers = {}\r\n            let request = {url, method, body, headers}\r\n            request.url = !soFetch.config.baseUrl || request.url.startsWith(\"http\") ? request.url : `${soFetch.config.baseUrl}${request.url}`\r\n            await sleep(0) //Allows the promise to be initialised\r\n            request = promise.transformRequest(request)\r\n            request = soFetch.config.transformRequest(request)\r\n            const {files, jsonPayload} = normalisePayload(request.body)\r\n            let init = files ? makeFilesRequest(request, files) : makeJsonRequest(request)\r\n            init = promise.transformInit(init)\r\n\r\n            const response = await Promise.race([\r\n                fetch(request.url, init),\r\n                new Promise<Response>((_, reject) =>\r\n                    setTimeout(() => reject(new Error(\"SoFetch timed out\")), promise.timeout)\r\n                )\r\n            ]);\r\n            if (soFetch.verbose) {\r\n                console.info(`SoFetch: ${init.method} ${response.status} ${request.url}`)\r\n            }\r\n            promise.dispatchEvent(new CustomEvent(\"onRequestSuccess\", {detail:response}))\r\n            if (!response.ok) {\r\n                const requestHandled = promise.handleHttpError(response)\r\n                const configHandled = soFetch.config.handleHttpError(response)\r\n                if (!requestHandled && !configHandled) {\r\n                    throw new Error(`Received response ${response.status} from URL ${response.url}`, {cause: response})\r\n                }\r\n            }\r\n            const returnObject = await handleResponse(response)\r\n            resolve(returnObject)\r\n        })().catch(e => {\r\n            reject(e)\r\n        })\r\n    })\r\n    return promise\r\n}\r\n\r\nexport interface SoFetchRequest {\r\n    url:string,\r\n    method:string,\r\n    body:object | undefined\r\n    headers:Record<string,string>\r\n}\r\n\r\nconst makeJsonRequest = (request:SoFetchRequest):RequestInit => {\r\n    const {url, method, body} = request\r\n    request.headers['content-type'] = 'application/json'\r\n    const init = {\r\n        body: body ? JSON.stringify(body) : undefined,\r\n        headers: request.headers,\r\n        method,\r\n        credentials: \"include\" as RequestCredentials\r\n    }\r\n    return init\r\n}\r\n\r\nconst makeFilesRequest = (request:SoFetchRequest, files:FileWithFieldName[]):RequestInit => {\r\n    const {method, headers} = request\r\n    const formData = new FormData()\r\n    files.forEach(f => {\r\n        formData.append(f.fieldName, f.file, f.file.name)\r\n    })\r\n    const init = {\r\n        body: formData,\r\n        headers,\r\n        method,\r\n        credentials: \"include\" as RequestCredentials\r\n    }\r\n    return init\r\n}\r\n\r\nconst handleResponse = async (response:Response) => {\r\n\r\n    if (response.status === 203) {\r\n        return undefined\r\n    }\r\n\r\n    const responseBody = await response.text();\r\n    if (!responseBody) {\r\n        return undefined\r\n    }\r\n    let responseObject: any = responseBody\r\n    try {\r\n        responseObject = JSON.parse(responseBody);\r\n    } catch {\r\n    }\r\n\r\n    return responseObject\r\n}\r\n\r\nconst soFetch = (<TResponse>(url: string, body?: object | File | File[], files?:File | File[]): SoFetchPromise<TResponse> => {\r\n    return makeRequestWrapper<TResponse>(body ? \"POST\" : \"GET\", url,  body)\r\n}) as SoFetchLike;\r\n\r\nsoFetch.verbose = false;\r\nsoFetch.config = soFetch.config || new SoFetchConfig()\r\n\r\nsoFetch.get = (url: string, body?: object) => {\r\n    return makeRequestWrapper(\"GET\", url, body)\r\n}\r\n\r\nsoFetch.post = (url: string, body?: object) => {\r\n    return makeRequestWrapper(\"POST\", url, body)\r\n}\r\n\r\nsoFetch.put = (url: string, body?: object) => {\r\n    return makeRequestWrapper(\"PUT\", url, body)\r\n}\r\n\r\nsoFetch.patch = (url: string, body?: object) => {\r\n    return makeRequestWrapper(\"PATCH\", url, body)\r\n}\r\n\r\nsoFetch.delete = (url: string, body?: object) => {\r\n    return makeRequestWrapper(\"DELETE\", url, body)\r\n}\r\n\r\nexport default soFetch;\r\n", "import soFetch, { SoFetchRequest } from \"./soFetch.ts\";\r\nimport {SoFetchLike} from \"./soFetch.ts\";\r\nimport {SoFetchPromise} from \"./soFetchPromise.ts\";\r\nimport {SoFetchConfig} from \"./soFetchConfig.ts\";\r\n\r\nexport default soFetch\r\n\r\nexport {SoFetchPromise, SoFetchConfig}\r\n\r\nexport type {SoFetchLike, SoFetchRequest}"],
  "mappings": "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",
  "names": ["SoFetchConfig", "status", "handler", "response", "handled", "h", "username", "password", "headerValue", "request", "token", "headerName", "value", "paramName", "url", "SoFetchPromise", "executor", "handler", "e", "status", "response", "handled", "h", "request", "init", "ms", "sleep", "ms", "resolve", "normalisePayload", "payload", "isDefined", "isArray", "isFiles", "getPayloadType", "fileArray", "isFileWithFieldName", "x", "i", "v", "makeRequestWrapper", "method", "url", "body", "files", "promise", "SoFetchPromise", "resolve", "reject", "request", "soFetch", "sleep", "jsonPayload", "normalisePayload", "init", "makeFilesRequest", "makeJsonRequest", "response", "_", "requestHandled", "configHandled", "returnObject", "handleResponse", "e", "headers", "formData", "f", "responseBody", "responseObject", "SoFetchConfig", "soFetch_default", "index_default", "soFetch_default"]
}
