"use strict";var R=Object.defineProperty;var v=Object.getOwnPropertyDescriptor;var E=Object.getOwnPropertyNames;var j=Object.prototype.hasOwnProperty;var D=(r,t)=>{for(var e in t)R(r,e,{get:t[e],enumerable:!0})},w=(r,t,e,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of E(t))!j.call(r,n)&&n!==e&&R(r,n,{get:()=>t[n],enumerable:!(s=v(t,n))||s.enumerable});return r};var A=r=>w(R({},"__esModule",{value:!0}),r);var $={};D($,{SoFetchConfig:()=>c,SoFetchPromise:()=>h,default:()=>N});module.exports=A($);var c=class{constructor(){this.errorHandlers={};this.beforeSendHandlers=[];this.onRequestCompleteHandlers=[];this.baseUrl=""}addHTTPHandler(t,e){this.errorHandlers[t]||(this.errorHandlers[t]=[]),this.errorHandlers[t].push(e)}handleHttpError(t){let e=t.status,s=this.errorHandlers[e]&&this.errorHandlers[e].length;return s&&this.errorHandlers[e].forEach(n=>n(t)),s}setBasicAuthentication({username:t,password:e}){let n=`Basic ${btoa(`${t}:${e}`)}`;this.beforeSend(d=>{d.headers.Authorization=n})}setBearerToken(t){this.beforeSend(e=>{e.headers.Authorization=`Bearer ${t}`})}setHeaderApiKey({headerName:t,value:e}){this.beforeSend(s=>{s.headers[t]=e})}setQueryStringApiKey({paramName:t,value:e}){this.beforeSend(s=>{let n=new URL(s.url);n.searchParams.append(t,e),s.url=n.toString()})}beforeSend(t){this.beforeSendHandlers.push(t)}transformRequest(t){return this.beforeSendHandlers.forEach(e=>{t=e(t)||t}),t}onRequestComplete(t){this.onRequestCompleteHandlers.push(t)}};var h=class extends EventTarget{constructor(e){super();this.errorHandlers={};this.beforeSendHandlers=[];this.beforeFetchSendHandlers=[];this.timeout=3e4;this.inner=new Promise(e),this.then=this.inner.then.bind(this.inner),this.catch=this.inner.catch.bind(this.inner),this.finally=this.inner.finally.bind(this.inner)}onRequestComplete(e){return this.addEventListener("onRequestSuccess",s=>{e(s.detail)}),this}beforeSend(e){return this.beforeSendHandlers.push(e),this}beforeFetchSend(e){return this.beforeFetchSendHandlers.push(e),this}catchHTTP(e,s){return this.errorHandlers[e]||(this.errorHandlers[e]=[]),this.errorHandlers[e].push(s),this}handleHttpError(e){let s=e.status,n=this.errorHandlers[s]&&this.errorHandlers[s].length;return n&&this.errorHandlers[s].forEach(d=>d(e)),n}transformRequest(e){return this.beforeSendHandlers.forEach(s=>{e=s(e)||e}),e}transformInit(e){return this.beforeFetchSendHandlers.forEach(s=>{e=s(e)||e}),e}async setTimeout(e){return this.timeout=e,this}};function g(r){return new Promise(t=>setTimeout(t,r))}var q=r=>{let{isDefined:t,isArray:e,isFiles:s}=C(r);if(!t)return{};if(!s)return{jsonPayload:r};let n=e?r:[r];return{files:S(n[0])?n:n.map(((u,f)=>({file:u,fieldName:`file${f}`})))}},S=r=>"file"in r&&r.file instanceof File,C=r=>r?Array.isArray(r)?r.length?r[0]instanceof File?{isDefined:!0,isArray:!0,isFiles:!0}:S(r[0])?{isDefined:!0,isArray:!0,isFiles:!0}:{isDefined:!0,isArray:!0,isFiles:!1}:{isDefined:!1,isArray:!0,isFiles:!1}:r instanceof File?{isDefined:!0,isArray:!1,isFiles:!0}:S(r)?{isDefined:!0,isArray:!1,isFiles:!0}:{isDefined:!0,isArray:!1,isFiles:!1}:{isDefined:!1,isArray:!1,isFiles:!1};var a=(r,t,e,s)=>{let n=new h((d,u)=>{(async()=>{let i={url:e,method:t,body:s,headers:{}};i.url=!r.baseUrl||i.url.startsWith("http")?i.url:`${r.baseUrl}${i.url}`,await g(0),i=n.transformRequest(i),i=r.transformRequest(i);let{files:b,jsonPayload:I}=q(i.body),m=b?k(i,b):U(i);m=n.transformInit(m);let T=new Date().getTime(),l=await Promise.race([fetch(i.url,m),new Promise((p,F)=>setTimeout(()=>F(new Error("SoFetch timed out")),n.timeout))]),P=new Date().getTime()-T;if(o.verbose&&console.info(`SoFetch: ${m.method} ${l.status} ${i.url}`),n.dispatchEvent(new CustomEvent("onRequestSuccess",{detail:l})),r.onRequestCompleteHandlers.forEach(p=>{p(l,{duration:P,method:i.method})}),!l.ok){let p=n.handleHttpError(l),F=r.handleHttpError(l);if(!p&&!F)throw new Error(`Received response ${l.status} from URL ${l.url}`,{cause:l})}let y=await x(l);d(y)})().catch(f=>{u(f)})});return n},U=r=>{let{url:t,method:e,body:s}=r;return r.headers["content-type"]="application/json",{body:s?JSON.stringify(s):void 0,headers:r.headers,method:e,credentials:"include"}},k=(r,t)=>{let{method:e,headers:s}=r,n=new FormData;return t.forEach(u=>{n.append(u.fieldName,u.file,u.file.name)}),{body:n,headers:s,method:e,credentials:"include"}},x=async r=>{if(r.status===203)return;let t=await r.text();if(!t)return;let e=t;try{e=JSON.parse(t)}catch{}return e},o=((r,t)=>a(o.config||new c,t?"POST":"GET",r,t));o.verbose=!1;o.config=new c;o.get=(r,t)=>a(o.config,"GET",r,t);o.post=(r,t)=>a(o.config,"POST",r,t);o.put=(r,t)=>a(o.config,"PUT",r,t);o.patch=(r,t)=>a(o.config,"PATCH",r,t);o.delete=(r,t)=>a(o.config,"DELETE",r,t);o.instance=()=>{let r=new c;r.baseUrl=o.config.baseUrl,r.beforeSendHandlers=[...o.config.beforeSendHandlers],r.onRequestCompleteHandlers=[...o.config.onRequestCompleteHandlers];let t=((e,s)=>a(r,s?"POST":"GET",e,s));return t.get=(e,s)=>a(r,"GET",e,s),t.post=(e,s)=>a(r,"POST",e,s),t.put=(e,s)=>a(r,"PUT",e,s),t.patch=(e,s)=>a(r,"PATCH",e,s),t.delete=(e,s)=>a(r,"DELETE",e,s),t.verbose=o.verbose,t.config=r,t};var H=o;var N=H;0&&(module.exports={SoFetchConfig,SoFetchPromise});
//# sourceMappingURL=index.cjs.map
