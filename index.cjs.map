{
  "version": 3,
  "sources": ["src/index.ts", "src/soFetchConfig.ts", "src/soFetchPromise.ts", "src/sleep.ts", "src/getPayloadType.ts", "src/handleHttpErrors.ts", "src/transformRequest.ts", "src/handleBeforeFetchSend.ts", "src/soFetch.ts"],
  "sourcesContent": ["import soFetch, { SoFetchRequest } from \"./soFetch.ts\";\r\nimport {SoFetchPromise} from \"./soFetchPromise.ts\";\r\nimport {SoFetchConfig} from \"./soFetchConfig.ts\";\r\nimport {SoFetchLike} from \"./soFetchLike.ts\";\r\n\r\nexport default soFetch\r\n\r\nexport {SoFetchPromise, SoFetchConfig}\r\n\r\nexport type {SoFetchLike, SoFetchRequest}", "import {ErrorHandlerDict} from \"./errorHandlerDict.ts\";\r\nimport {SoFetchRequest} from \"./soFetch.ts\";\r\n\r\n/**\r\n * Configures all requests for a specific soFetch instance\r\n */\r\nexport class SoFetchConfig {\r\n    errorHandlers: ErrorHandlerDict = {}\r\n    beforeSendHandlers: ((request: SoFetchRequest) => SoFetchRequest | void)[] = []\r\n    onRequestCompleteHandlers: ((response: Response, requestData: { duration: number, method: string }) => void)[] = []\r\n\r\n    /**\r\n     * The base URL for all HTTP requests in the instance. If absent this is assumed to be the current base url.\r\n     * If running in Node relative requests without a baseUrl will throw an error.\r\n     */\r\n    baseUrl: string = \"\"\r\n\r\n    /**\r\n     * Adds a handler which will be executed on receipt from the server of the specified status code.\r\n     * Multiple handlers will be executed in the order in which they are added. If a request has it's\r\n     * own handler(s) for a given status code the corresponding handlers in the config will not be executed.\r\n     * @param status An HTTP status code\r\n     * @param handler A function which accepts a Fetch Response as an argument\r\n     * @example\r\n     *\r\n     *    soFetchConfig.catchHttp(404, (res:Response) => {\r\n     *         alert(\"This object can't be found\")\r\n     *     })\r\n     *\r\n     * @see For more examples see https://sofetch.antoinette.agency\r\n     */\r\n    catchHTTP(status: number, handler: (res: Response) => void) {\r\n        if (!this.errorHandlers[status]) {\r\n            this.errorHandlers[status] = []\r\n        }\r\n        this.errorHandlers[status].push(handler)\r\n    }\r\n\r\n    /**\r\n     * Causes a basic authorization header to be sent with each request in this soFetch instance.\r\n     * @param username\r\n     * @param password\r\n     * @example\r\n     *\r\n     *    soFetch.config.setBasicAuthentication({username:\"Chris Hodges\", password:\"Antoinette\"})\r\n     *\r\n     * @see For more examples see https://sofetch.antoinette.agency\r\n     */\r\n    setBasicAuthentication({username, password}: { password: string; username: string }) {\r\n        const token = btoa(`${username}:${password}`);\r\n        const headerValue = `Basic ${token}`\r\n        this.beforeSend((request: SoFetchRequest) => {\r\n            request.headers[\"Authorization\"] = headerValue\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Causes a bearer token authorization token to be sent with each request in this sofetch instance\r\n     * @param token\r\n     * @example\r\n     *\r\n     *    soFetch.config.setBearerToken(\"SOME_ACCESS_TOKEN\")\r\n     *\r\n     * @see For more examples see https://sofetch.antoinette.agency\r\n     */\r\n    setBearerToken(token: string) {\r\n        this.beforeSend((request: SoFetchRequest) => {\r\n            request.headers[\"Authorization\"] = `Bearer ${token}`\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Causes a header with the specified key and value to be sent with each request in this sofetch instance\r\n     * @param headerName\r\n     * @param value\r\n     * @example\r\n     * \r\n     *    soFetch.config.setHeaderApiKey({headerName:\"some-api-key\", value:\"HEADER_ACCESS_TOKEN\"})\r\n     *    \r\n     * @see For more examples see https://sofetch.antoinette.agency\r\n     */\r\n    setHeaderApiKey({headerName, value}: { headerName: string; value: string }) {\r\n        this.beforeSend((request: SoFetchRequest) => {\r\n            request.headers[headerName] = value\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Causes a query string entry with the specified key and value to be sent with each request in this sofetch instance\r\n     * @param paramName\r\n     * @param value\r\n     * @example\r\n     *    soFetch.config.setQueryStringApiKey({paramName:\"api-key\", value:\"QUERY_STRING_ACCESS_TOKEN\"})\r\n     * @see For more examples see https://sofetch.antoinette.agency\r\n     */\r\n    setQueryStringApiKey({paramName, value}: { paramName: string; value: string }) {\r\n        this.beforeSend((request: SoFetchRequest) => {\r\n            const url = new URL(request.url)\r\n            url.searchParams.append(paramName, value)\r\n            request.url = url.toString()\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Adds a handler which will be executed before every request. beforeSend handlers on the config\r\n     * will be executed before request-specific handlers\r\n     * @param handler\r\n     * @example\r\n     * \r\n     *    soFetch.config.beforeSend((req:SoFetchRequest) => {\r\n     *       console.info(`Sending ${req.method} request to URL ${req.url}`\r\n     *    })\r\n     *    \r\n     * @see For more examples see https://sofetch.antoinette.agency\r\n     */\r\n    beforeSend(handler: (request: SoFetchRequest) => SoFetchRequest | void) {\r\n        this.beforeSendHandlers.push(handler)\r\n    }\r\n\r\n    /**\r\n     * Adds a handler which will be executed after every request. Handlers will fire regardless of whether\r\n     * the response status code indicated an error\r\n     * @param handler\r\n     * @example\r\n     *\r\n     *    soFetch.config.onRequestComplete((r: Response) => {\r\n     *       console.info(`Response received from ${r.url} with status ${r.status}`\r\n     *    })\r\n     *\r\n     * @see For more examples see https://sofetch.antoinette.agency\r\n     */\r\n    onRequestComplete(handler: (r: Response, metaData: { duration: number, method: string }) => void) {\r\n        this.onRequestCompleteHandlers.push(handler)\r\n    }\r\n}\r\n", "import {ErrorHandlerDict} from \"./errorHandlerDict.ts\";\r\nimport {SoFetchRequest} from \"./soFetch.ts\";\r\n\r\n/**\r\n * An awaitable promise-like class which additionally allows event and error handlers to be attached to the HTTP request\r\n * @example\r\n * \r\n *    const unicorn = await soFetch(\"https://unicorns.com/1234\")\r\n *      .beforeSend(req:SoFetchRequest) => {\r\n *          console.info(`Finding my unicorn at ${req.url}`)\r\n *       })\r\n *      .catchHttp(404, (res:Response) => {\r\n *         console.error(\"This unicorn can't be found\")\r\n *     })\r\n */\r\nexport class SoFetchPromise<T> {\r\n    private readonly inner: Promise<T>;\r\n    errorHandlers:ErrorHandlerDict = {}\r\n    beforeSendHandlers:((request:SoFetchRequest) => SoFetchRequest | void)[] = []\r\n    beforeFetchSendHandlers:((init:RequestInit) => RequestInit | void)[] = []\r\n    onRequestCompleteHandlers: ((response: Response, requestData: { duration: number, method: string }) => void)[] = []\r\n    timeout: number = 30000\r\n    then: Promise<T>[\"then\"];\r\n    catch: Promise<T>[\"catch\"];\r\n    finally: Promise<T>[\"finally\"];\r\n    \r\n    constructor(executor: (\r\n        resolve: (value: T | PromiseLike<T>) => void,\r\n        reject: (reason?: any) => void\r\n    ) => void) {\r\n        this.inner = new Promise(executor);\r\n        // Bind promise methods once inner exists\r\n        this.then = this.inner.then.bind(this.inner);\r\n        this.catch = this.inner.catch.bind(this.inner);\r\n        this.finally = this.inner.finally.bind(this.inner);\r\n    }\r\n\r\n    /**\r\n     * Adds a handler which will be executed after this HTTP request is completed. Handlers will fire regardless of whether\r\n     * the response status code indicated an error\r\n     * @param handler\r\n     * @example\r\n     *\r\n     *    await soFetch(\"https://example.com/users\",{name:\"Sarah\", id:1234}).onRequestComplete((r: Response) => {\r\n     *       console.info(`Response received from ${r.url} with status ${r.status}`\r\n     *    })\r\n     *\r\n     * @see For more examples see https://sofetch.antoinette.agency\r\n     */\r\n    onRequestComplete(handler: (response: Response) => void): SoFetchPromise<T> {\r\n        this.onRequestCompleteHandlers.push(handler)\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Adds a handler which will be executed before this HTTP request is sent. BeforeSend handlers added here will\r\n     * will be executed after those added on the config.\r\n     * @param handler\r\n     * @example\r\n     *\r\n     *    await soFetch(\"https://example.com/users\",{name:\"Sarah\", id:1234}).beforeSend((req:SoFetchRequest) => {\r\n     *       console.info(`Sending ${req.method} request to URL ${req.url}`\r\n     *    })\r\n     *\r\n     * @see For more examples see https://sofetch.antoinette.agency\r\n     */\r\n    beforeSend(handler: (request: SoFetchRequest) => SoFetchRequest | void): SoFetchPromise<T> {\r\n        this.beforeSendHandlers.push(handler)\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Adds a handler which allows developers to modify the low-level fetch RequestInit object before the HTTP\r\n     * request is made. These handlers execute after beforeSend handlers. This is useful for one-off\r\n     * occasions when you need to access some aspect of the low-level Fetch API. If you're using this a lot\r\n     * it might make more sense for you to use the Fetch API directly.\r\n     * @param handler\r\n     * @example\r\n     *\r\n     *    //An example of how you might send both files and data in a single request.\r\n     *    const postFilesAndDataResponse = await soFetch.put<PostFilesAndDataResponse>(\"https://example.com/files-and-data\").beforeFetchSend((init:RequestInit) => {\r\n     *       const formData = new FormData()\r\n     *       formData.append(\"company\", \"Antoinette\");\r\n     *       formData.append(\"file1\", myFile)\r\n     *       const headers = {...init.headers} as Record<string,string>\r\n     *       if (headers[\"content-type\"]) {\r\n     *           delete headers[\"content-type\"]\r\n     *       }\r\n     *       init.body = formData\r\n     *       init.headers = headers\r\n     *       return init\r\n     *    })\r\n     *\r\n     * @see For more examples see https://sofetch.antoinette.agency\r\n     */\r\n    beforeFetchSend(handler: (request: RequestInit) => RequestInit | void): SoFetchPromise<T> {\r\n        this.beforeFetchSendHandlers.push(handler)\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Adds a handler which will be executed on receipt from the server of the specified status code.\r\n     * Multiple handlers will be executed in the order in which they are added. If you add an error handler\r\n     * for a specific status code here any corresponding handlers in the config will not be executed.\r\n     * @param status An HTTP status code\r\n     * @param handler A function which accepts a Fetch Response as an argument\r\n     * @example\r\n     *\r\n     *    const unicorn = await soFetch(\"https://unicorns.com/1234\")\r\n     *      .catchHttp(404, (res:Response) => {\r\n     *         console.error(\"This unicorn can't be found\")\r\n     *     })\r\n     *\r\n     * @see For more examples see https://sofetch.antoinette.agency\r\n     */\r\n    catchHTTP(status: number, handler: (response: Response) => void): SoFetchPromise<T> {\r\n        if (!this.errorHandlers[status]) {\r\n            this.errorHandlers[status] = []\r\n        }\r\n        this.errorHandlers[status].push(handler)\r\n        return this\r\n    }\r\n\r\n    async setTimeout(ms: number) {\r\n        this.timeout = ms\r\n        return this\r\n    }\r\n}\r\n", "export function sleep(ms: number) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}", "import {UploadPayload} from \"./uploadPayload.ts\";\r\nimport {FileWithFieldName} from \"./fileWithFieldName.ts\";\r\n\r\nexport const normalisePayload = (payload:UploadPayload):{files?:FileWithFieldName[], jsonPayload?:object} => {\r\n    const {isDefined, isArray, isFiles} = getPayloadType(payload)\r\n    if (!isDefined) {\r\n        return {}\r\n    }\r\n    if (!isFiles) {\r\n        return {jsonPayload:payload}\r\n    }\r\n    const fileArray = (isArray ? payload : [payload]) as (File[] | FileWithFieldName[])\r\n    const files = (isFileWithFieldName(fileArray[0]) ? fileArray : fileArray.map(((x,i) => ({file:x, fieldName:`file${i}`})))) as FileWithFieldName[]\r\n    return {files}\r\n}\r\n\r\nexport const isFileWithFieldName = (v:object) => {\r\n    return 'file' in v && v.file instanceof File\r\n}\r\n\r\nexport const getPayloadType = (payload: UploadPayload): { isDefined: boolean, isArray: boolean, isFiles: boolean } => {\r\n    if (!payload) {\r\n        return {isDefined: false, isArray: false, isFiles: false}\r\n    }\r\n    if (Array.isArray(payload)) {\r\n        if (!payload.length) {\r\n            //For the purposes of the HTTP request a payload which is an empty array is undefined\r\n            //We won't be sending a body with the request.\r\n            return {isDefined: false, isArray: true, isFiles: false}\r\n        }\r\n        if (payload[0] instanceof File) {\r\n            return {isDefined: true, isArray: true, isFiles: true}\r\n        }\r\n        if (isFileWithFieldName(payload[0])) {\r\n            return {isDefined: true, isArray: true, isFiles: true}\r\n        }\r\n        return {isDefined: true, isArray: true, isFiles: false}\r\n    }\r\n    if (payload instanceof File) {\r\n        return {isDefined: true, isArray: false, isFiles: true}\r\n    }\r\n    if (isFileWithFieldName(payload)) {\r\n        return {isDefined: true, isArray: false, isFiles: true}\r\n    }\r\n    return {isDefined: true, isArray: false, isFiles: false}\r\n}", "import {ErrorHandlerDict} from \"./errorHandlerDict.ts\";\r\n\r\nexport const handleHttpErrors = (response: Response, errorHandlers: ErrorHandlerDict) => {\r\n    const status = response.status\r\n    const handled = !!(errorHandlers[status] && errorHandlers[status].length)\r\n    if (handled) {\r\n        errorHandlers[status].forEach(h => h(response))\r\n    }\r\n    return handled\r\n}", "import {SoFetchRequest} from \"./soFetch.ts\";\r\n\r\nexport const transformRequest = (request: SoFetchRequest, beforeSendHandlers: ((request: SoFetchRequest) => SoFetchRequest | void)[]) => {\r\n    beforeSendHandlers.forEach(h => {\r\n        request = h(request) || request\r\n    })\r\n    return request\r\n}", "export const handleBeforeFetchSend = (init: RequestInit, handlers: ((init: RequestInit) => RequestInit | void)[]) => {\r\n    handlers.forEach(h => {\r\n        init = h(init) || init\r\n    })\r\n    return init\r\n}", "import {SoFetchConfig} from \"./soFetchConfig.ts\";\r\nimport {SoFetchPromise} from \"./soFetchPromise.ts\";\r\nimport {sleep} from \"./sleep.ts\";\r\nimport {UploadPayload} from \"./uploadPayload.ts\";\r\nimport {normalisePayload} from \"./getPayloadType.ts\";\r\nimport {FileWithFieldName} from \"./fileWithFieldName.ts\";\r\nimport {SoFetchLike} from \"./soFetchLike.ts\";\r\nimport {handleHttpErrors} from \"./handleHttpErrors.ts\";\r\nimport {transformRequest} from \"./transformRequest.ts\";\r\nimport {handleBeforeFetchSend} from \"./handleBeforeFetchSend.ts\";\r\n\r\n/** @import { UploadPayload } from \"./uploadPayload.ts\" */\r\n\r\nconst convertArgsToFetchInit = async <T>({url, method, body, config, promise}: { url: string, method:string, body?:UploadPayload, config:SoFetchConfig, promise:SoFetchPromise<T> }) => {\r\n    const headers = {}\r\n    let request = {url, method, body, headers}\r\n    request.url = !config.baseUrl || request.url.startsWith(\"http\") ? request.url : `${config.baseUrl}${request.url}`\r\n    request = transformRequest(request, promise.beforeSendHandlers)\r\n    request = transformRequest(request, config.beforeSendHandlers)\r\n    const {files, jsonPayload} = normalisePayload(request.body)\r\n    let init = files ? makeFilesRequest(request, files) : makeJsonRequest(request)\r\n    init = handleBeforeFetchSend(init, promise.beforeFetchSendHandlers)\r\n    return {init, finalUrl:request.url}\r\n}\r\n\r\nconst makeRequestWrapper = <TResponse>(config: SoFetchConfig, method:string, url:string, body?:UploadPayload) => {\r\n    const promise = new SoFetchPromise<TResponse>((resolve, reject) => {\r\n        (async () => {\r\n            await sleep(0) //Allows the promise to be initialised\r\n            const {finalUrl, init} = await convertArgsToFetchInit({url, method, body, config, promise})\r\n            \r\n            const startTime = new Date().getTime()\r\n            const response = await Promise.race([\r\n                fetch(finalUrl, init),\r\n                new Promise<Response>((_, reject) =>\r\n                    setTimeout(() => reject(new Error(\"SoFetch timed out\")), promise.timeout)\r\n                )\r\n            ]);\r\n            const duration = new Date().getTime() - startTime\r\n            \r\n            if (soFetch.verbose) {\r\n                console.info(`SoFetch: ${method} ${response.status} ${finalUrl}`)\r\n            }\r\n            promise.onRequestCompleteHandlers.forEach(h => {\r\n                h(response, {duration, method:init.method || \"\"})\r\n            })\r\n            config.onRequestCompleteHandlers.forEach(h => {\r\n                h(response, {duration, method:init.method || \"\"})\r\n            })\r\n            if (!response.ok) {\r\n                const requestHandled = handleHttpErrors(response, promise.errorHandlers)\r\n                let configHandled = false\r\n                if (!requestHandled) {\r\n                    configHandled = handleHttpErrors(response, config.errorHandlers)\r\n                }\r\n                if (!requestHandled && !configHandled) {\r\n                    // @ts-ignore\r\n                    throw new Error(`Received response ${response.status} from URL ${response.url}`, {cause: response})\r\n                }\r\n            }\r\n            const returnObject = await handleResponse(response)\r\n            resolve(returnObject)\r\n        })().catch(e => {\r\n            reject(e)\r\n        })\r\n    })\r\n    return promise\r\n}\r\n\r\nexport interface SoFetchRequest {\r\n    url:string,\r\n    method:string,\r\n    body:object | undefined\r\n    headers:Record<string,string>\r\n}\r\n\r\nconst makeJsonRequest = (request:SoFetchRequest):RequestInit => {\r\n    const {url, method, body} = request\r\n    request.headers['content-type'] = 'application/json'\r\n    const init = {\r\n        body: body ? JSON.stringify(body) : undefined,\r\n        headers: request.headers,\r\n        method,\r\n        credentials: \"include\" as RequestCredentials\r\n    }\r\n    return init\r\n}\r\n\r\nconst makeFilesRequest = (request:SoFetchRequest, files:FileWithFieldName[]):RequestInit => {\r\n    const {method, headers} = request\r\n    const formData = new FormData()\r\n    files.forEach(f => {\r\n        formData.append(f.fieldName, f.file, f.file.name)\r\n    })\r\n    const init = {\r\n        body: formData,\r\n        headers,\r\n        method,\r\n        credentials: \"include\" as RequestCredentials\r\n    }\r\n    return init\r\n}\r\n\r\nconst handleResponse = async (response:Response) => {\r\n\r\n    if (response.status === 203) {\r\n        return undefined\r\n    }\r\n\r\n    const responseBody = await response.text();\r\n    if (!responseBody) {\r\n        return undefined\r\n    }\r\n    let responseObject: any = responseBody\r\n    try {\r\n        responseObject = JSON.parse(responseBody);\r\n    } catch {\r\n    }\r\n\r\n    return responseObject\r\n}\r\n\r\n/**\r\n * Makes an HTTP request to the specified URL.\r\n * @template TResponse The primitive or object type you're expecting from the server\r\n * @param {string} url An absolute or relative URL\r\n * @param {UploadPayload} [body] If absent soFetch will make a GET request. If present soFetch will make a POST request. To make PUT, PATCH, DELETE requests see soFetch.put, soFetch.patch, soFetch.delete\r\n * @returns An awaitable SoFetchPromise which resolves to type TResponse\r\n * @example\r\n * \r\n *    const products = await soFetch<Product[]>(\"/api/products\")\r\n *    \r\n * @see For more examples see https://sofetch.antoinette.agency\r\n */\r\nconst soFetch = (<TResponse>(url: string, body?: UploadPayload): SoFetchPromise<TResponse> => {\r\n    return makeRequestWrapper<TResponse>(soFetch.config || new SoFetchConfig(), body ? \"POST\" : \"GET\", url,  body)\r\n}) as SoFetchLike;\r\n\r\nsoFetch.verbose = false;\r\n\r\n\r\nsoFetch.config = new SoFetchConfig()\r\n\r\n/**\r\n * Makes a GET request to the specified URL\r\n * @template TResponse The primitive or object type you're expecting from the server\r\n * @param url An absolute or relative URL\r\n * @returns An awaitable SoFetchPromise which resolves to type TResponse\r\n * @example\r\n *\r\n *    const products = await soFetch.get<Product[]>(\"/api/products\")\r\n *\r\n * @see For more examples see https://sofetch.antoinette.agency\r\n */\r\nsoFetch.get = (url: string) => {\r\n    return makeRequestWrapper( soFetch.config,\"GET\", url)\r\n}\r\n\r\n/**\r\n * Makes a POST request to the specified URL\r\n * @template TResponse The primitive or object type you're expecting from the server\r\n * @param url An absolute or relative URL\r\n * @param {UploadPayload} [body] The body of the request\r\n * @returns An awaitable SoFetchPromise which resolves to type TResponse\r\n * @example\r\n *\r\n *    const newUser = {\r\n *        name:\"Regina George\",\r\n *        email:\"regina@massive-deal.com\"\r\n *    }\r\n *    const successResponse = await soFetch.post<Success>(\"/api/users\", newUser)\r\n *\r\n * @see For more examples see https://sofetch.antoinette.agency\r\n */\r\nsoFetch.post = (url: string, body?: object) => {\r\n    return makeRequestWrapper(soFetch.config,\"POST\", url, body)\r\n}\r\n\r\n/**\r\n * Makes a PUT request to the specified URL\r\n * @template TResponse The primitive or object type you're expecting from the server\r\n * @param url An absolute or relative URL\r\n * @param {UploadPayload} [body] The body of the request\r\n * @returns An awaitable SoFetchPromise which resolves to type TResponse\r\n * @example\r\n *\r\n *    const upsertUser = {\r\n *        name:\"Regina George\",\r\n *        email:\"regina@massive-deal.com\"\r\n *    }\r\n *    const successResponse = await soFetch.put<Success>(\"/api/users/1234\", upsertUser)\r\n *\r\n * @see For more examples see https://sofetch.antoinette.agency\r\n */\r\nsoFetch.put = (url: string, body?: object) => {\r\n    return makeRequestWrapper(soFetch.config,\"PUT\", url, body)\r\n}\r\n\r\n/**\r\n * Makes a PATCH request to the specified URL\r\n * @template TResponse The primitive or object type you're expecting from the server\r\n * @param url An absolute or relative URL\r\n * @param {UploadPayload} [body] The body of the request\r\n * @returns An awaitable SoFetchPromise which resolves to type TResponse\r\n * @example\r\n *\r\n *    const updateUserEmail = {\r\n *        email:\"regina@massive-deal.com\"\r\n *    }\r\n *    const successResponse = await soFetch.patch<Success>(\"/api/users/1234\", updateUserEmail)\r\n *\r\n * @see For more examples see https://sofetch.antoinette.agency\r\n */\r\nsoFetch.patch = (url: string, body?: object) => {\r\n    return makeRequestWrapper(soFetch.config,\"PATCH\", url, body)\r\n}\r\n\r\n/**\r\n * Makes a DELETE request to the specified URL\r\n * @template TResponse The primitive or object type you're expecting from the server\r\n * @param url An absolute or relative URL\r\n * @returns An awaitable SoFetchPromise which resolves to type TResponse\r\n * @example\r\n *\r\n *    await soFetch.delete(\"/api/users/1234\")\r\n *\r\n * @see For more examples see https://sofetch.antoinette.agency\r\n */\r\nsoFetch.delete = (url: string) => {\r\n    return makeRequestWrapper(soFetch.config,\"DELETE\", url)\r\n}\r\n\r\n/**\r\n * Returns an independent instance of soFetch configured as per the original. The baseUrl and event handlers\r\n * will be copied over.\r\n * \r\n * @see For examples see https://sofetch.antoinette.agency\r\n */\r\nsoFetch.instance = () => {\r\n    \r\n    const config = new SoFetchConfig()\r\n    config.baseUrl = soFetch.config.baseUrl\r\n    config.beforeSendHandlers = [...soFetch.config.beforeSendHandlers]\r\n    config.onRequestCompleteHandlers = [...soFetch.config.onRequestCompleteHandlers]\r\n    \r\n    const soFetchInstance = (<TResponse>(url: string, body?: UploadPayload): SoFetchPromise<TResponse> => {\r\n        return makeRequestWrapper<TResponse>(config,body ? \"POST\" : \"GET\", url,  body)\r\n    }) as SoFetchLike;\r\n    soFetchInstance.get = (url: string, body?: UploadPayload) => {\r\n        return makeRequestWrapper(config, \"GET\", url, body)\r\n    }\r\n    soFetchInstance.post = (url: string, body?: UploadPayload) => {\r\n        return makeRequestWrapper(config,\"POST\", url, body)\r\n    }\r\n    soFetchInstance.put = (url: string, body?: UploadPayload) => {\r\n        return makeRequestWrapper(config,\"PUT\", url, body)\r\n    }\r\n    soFetchInstance.patch = (url: string, body?: UploadPayload) => {\r\n        return makeRequestWrapper(config,\"PATCH\", url, body)\r\n    }\r\n    soFetchInstance.delete = (url: string, body?: UploadPayload) => {\r\n        return makeRequestWrapper(config,\"DELETE\", url, body)\r\n    }\r\n    soFetchInstance.verbose = soFetch.verbose\r\n    soFetchInstance.config = config\r\n    return soFetchInstance\r\n}\r\n\r\nexport default soFetch;\r\n"],
  "mappings": "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",
  "names": ["index_exports", "__export", "SoFetchConfig", "SoFetchPromise", "index_default", "__toCommonJS", "SoFetchConfig", "status", "handler", "username", "password", "headerValue", "request", "token", "headerName", "value", "paramName", "url", "SoFetchPromise", "executor", "handler", "status", "ms", "sleep", "ms", "resolve", "normalisePayload", "payload", "isDefined", "isArray", "isFiles", "getPayloadType", "fileArray", "isFileWithFieldName", "x", "i", "v", "handleHttpErrors", "response", "errorHandlers", "status", "handled", "h", "transformRequest", "request", "beforeSendHandlers", "h", "handleBeforeFetchSend", "init", "handlers", "h", "convertArgsToFetchInit", "url", "method", "body", "config", "promise", "request", "transformRequest", "files", "jsonPayload", "normalisePayload", "init", "makeFilesRequest", "makeJsonRequest", "handleBeforeFetchSend", "makeRequestWrapper", "SoFetchPromise", "resolve", "reject", "sleep", "finalUrl", "startTime", "response", "_", "duration", "soFetch", "h", "requestHandled", "handleHttpErrors", "configHandled", "returnObject", "handleResponse", "e", "headers", "formData", "f", "responseBody", "responseObject", "SoFetchConfig", "soFetchInstance", "soFetch_default", "index_default", "soFetch_default"]
}
